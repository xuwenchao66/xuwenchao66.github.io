# 状态模式

## 参考

[http://c.biancheng.net/view/1383.htmlhttps://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/state.html](https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/state.html)

[http://c.biancheng.net/view/1388.html](http://c.biancheng.net/view/1388.html)

## 定义

对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

状态模式跟策略模式非常相似，它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行，而不同之处在于，
策略模式中的策略类都是平行、没有联系的，而状态模式中的状态类的行为是早已封装好的，状态之间环环相扣，客户端无需了解
这些细节。

## 应用场景

状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，
如在政府 `OA` 办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。
使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。

### 适用场景

- 对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。

- 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。

## 实现思路

状态模式包含以下主要角色。

1. 环境（`Context`）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。

2. 抽象状态（`State`）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。

3. 具体状态（`Concrete State`）角色：实现抽象状态所对应的行为。

## 优点

1. 状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。

2. 减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。

3. 有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。

## 缺点

1. 状态模式的使用必然会增加系统的类与对象的个数。

2. 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。

## 代码实例

<<< @/docs/design-patterns/js/state.ts

<design-patterns-state />
